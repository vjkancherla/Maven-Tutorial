========================
MAVEN BUILD LIFECYCLE
========================

- The Maven build follows a specific lifecycle to deploy and distribute the target project.

- There are three built-in lifecycles:

    - default: the main lifecycle, as it’s responsible for project deployment
    - clean: to clean the project and remove all files generated by the previous build
    - site: to create the project’s site documentation

Each lifecycle consists of a sequence of phases. The default build lifecycle consists of 23 phases, as it’s the main build lifecycle.
On the other hand, the clean life cycle consists of 3 phases, while the site lifecycle is made up of 4 phases.


Here are the primary Maven lifecycle phases:

1.Validate:
    The validate phase is the earliest phase in the Maven lifecycle.
    In this phase, Maven checks the project's structure, validates the POM (Project Object Model) file, and ensures that all necessary information is available.

2. Initialize (initialize):
    The initialize phase initializes properties and sets up the environment for the build process.

3. Generate Sources (generate-sources):
    In the generate-sources phase, Maven generates any source code that might be required by the project. This is often used for code generation tasks.

4. Process Sources (process-sources):
    The process-sources phase is where source code is processed or transformed, such as by applying code generation or annotation processors.

5. Generate Resources (generate-resources):
    During the generate-resources phase, any resources (e.g., configuration files, templates) required for the project are generated.

6. Process Resources (process-resources):
    In the process-resources phase, resources are processed or filtered, allowing for variable substitution or other customizations.

7. Compile (compile):
    The compile phase compiles the project's source code, generating bytecode from the source files. This is where your Java or other source code is compiled.

8. Process Classes (process-classes):
    In the process-classes phase, post-compilation tasks can be applied to the compiled classes.

9. Generate Test Sources (generate-test-sources):
    Similar to the generate-sources phase, the generate-test-sources phase generates any additional source code required for testing.

10. Process Test Sources (process-test-sources):
    During the process-test-sources phase, any generated test sources are processed or transformed.

11. Generate Test Resources (generate-test-resources):
    The generate-test-resources phase generates resources needed for testing, such as test configuration files or data.

12. Process Test Resources (process-test-resources):
    Resources for testing are processed or filtered in the process-test-resources phase.

13. Test Compile (test-compile):
    In the test-compile phase, the test source code is compiled to create the test classes.

14. Process Test Classes (process-test-classes):
    Post-compilation tasks for test classes can be performed during the process-test-classes phase.

15. Test (test):
    The test phase runs the project's unit tests using a testing framework like JUnit or TestNG.

16. Prepare Package (prepare-package):
    In the prepare-package phase, the project is prepared for packaging, which might include tasks like assembling and preparing files for packaging.

17. Package (package):
    The package phase packages the compiled code and resources into the project's final artifact (e.g., JAR, WAR, etc.).

18. Pre-Integration Test (pre-integration-test):
    The pre-integration-test phase is used for pre-integration test setup and configuration, which may involve starting external services or containers.

19. Integration Test (integrat
ion-test):
    The integration-test phase runs integration tests, which test the interactions between different parts of the application.

20. Post-Integration Test (post-integration-test):
    After integration tests, the post-integration-test phase can be used for cleanup or post-test tasks.

21. Verify (verify):
    The verify phase checks the project's final artifact to ensure it meets quality and validation criteria. This phase typically includes checks for code quality, code coverage, and other quality-related metrics.

22. Install (install):
    In the install phase, the project's artifact is installed into the LOCAL Maven repository, making it available for other projects to use.

23. Deploy (deploy):
    The deploy phase deploys the project's artifact to a REMOTE repository, typically used for sharing artifacts with other team members or deploying them to a central repository.